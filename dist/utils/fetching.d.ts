/**
Использование Promise.race() — это классический способ реализации динамического пула запросов.
В отличие от статического разделения на «пачки», этот метод позволяет запускать новый запрос сразу же, как только освобождается «слот», не дожидаясь остальных запросов в группе.

Для реализации нам понадобятся:
AbortController — для отмены запроса по таймауту.
Promise.race() — для контроля лимита одновременных соединений.
Рекурсия или цикл для обработки ретраев.
 */
/**
 * Выполняет запрос с таймаутом и ретраями
 */
export declare function fetchWithRetries(url: string, retries: number, timeoutMs: number): Promise<any>;
/**
 * Основная функция управления очередью через Promise.race
 */
export declare function poolRequests(urls: string[], executingLimit: number, fetchRetries: number, fetchTimeoutMs: number): Promise<any[]>;
/**
Разбор ключевых моментов:
Зачем тут Promise.race(executing)?
Когда количество активных запросов (executing.size) достигает вашего лимита $N$, выполнение цикла for...of приостанавливается на строке await Promise.race(executing).
Как только любой из запущенных запросов завершается, он удаляет себя из Set и Promise.race «разрешается».
Цикл делает следующую итерацию и запускает новый запрос.
Это обеспечивает максимальную плотность потока.Абортирование (Таймаут):Мы используем AbortController.
Если сервер не ответил в течение timeoutMs, вызывается controller.abort(), запрос прерывается, и мы переходим к следующему ретраю (если они остались).
Обработка ошибок:В данном примере ошибки не «роняют» всё приложение.
Если после всех попыток URL не загрузился, в массив результатов записывается объект с описанием ошибки.
Это важно для обработки больших массивов данных
 */
export declare function runExample(): void;
/**
Почему это лучше альтернатив?
Память: Мы не создаем 1 000 000 промисов сразу, если в массиве миллион URL. Мы итерируемся по списку постепенно.
Скорость: Нет «бутылочного горлышка» как в Promise.all группами. Если один URL «тупит», остальные каналы продолжают молотить очередь.
Контроль: Вы жестко контролируете нагрузку на клиент и сервер.
Нюанс: Если вам нужно сохранять строгий порядок результатов (чтобы results[0] соответствовал urls[0]), в функцию fetchWithRetries стоит передавать индекс и записывать результат в массив по этому индексу: results[index] = data
 */
//# sourceMappingURL=fetching.d.ts.map